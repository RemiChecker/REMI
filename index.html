<!DOCTYPE html>
<!-- Presse Remi – Abgleich | Version 27.2.8 | Made by Durdu 2025 -->
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Presse Remi – Abgleich v27.2.8</title>
  <meta name="theme-color" content="#0a84ff">
  <style>
    :root{--blue:#0a84ff;--muted:#666}
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;margin:1rem auto;max-width:1200px;padding:0 1rem;background:#fff}
    header{display:flex;gap:12px;align-items:center}
    h1{font-size:1.45rem;margin:.5rem 0}
    .version{font-size:.8em;color:#666;margin-left:.5rem}
    h2{margin:.7rem 0 .35rem}
    h3{margin:.4rem 0}
    .muted{color:var(--muted);font-size:.95rem}
    .banner{margin:.75rem 0;padding:.6rem .8rem;border:1px solid #dbe5ff;background:#f4f7ff;border-radius:.6rem;color:#1a3daa}
    .pill{display:inline-block;padding:.2rem .5rem;border-radius:1rem;background:#eef3ff;color:#0a84ff;font-size:.85rem}
    .tabs{display:flex;gap:.5rem;flex-wrap:wrap;margin-top:.5rem}
    .tab{padding:.45rem .7rem;border:1px solid #d0d0d0;border-radius:.6rem;cursor:pointer}
    .tab.active{background:#0a84ff;color:#fff;border-color:#0a84ff}
    button{padding:.55rem .85rem;border-radius:.6rem;border:1px solid #d0d0d0;background:#fff;cursor:pointer}
    button.primary{background:#0a84ff;color:#fff;border-color:#0a84ff}
    textarea{width:100%;min-height:160px;border:1px solid #d0d0d0;border-radius:.6rem;padding:.6rem;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    input[type="text"],input[type="date"],select{padding:.5rem .65rem;border:1px solid #d0d0d0;border-radius:.6rem}
    .list{margin-top:.6rem}
    .card{border:1px solid #e8e8e8;border-radius:.8rem;padding:.75rem .9rem;margin:.5rem 0;background:#fff}
    details summary{list-style:none;cursor:pointer}
    details summary::-webkit-details-marker{display:none}
    .row{display:grid;grid-template-columns:120px 120px 1fr 160px;gap:.6rem;align-items:center}
    .chip{display:inline-block;border:1px solid #e0e0e0;border-radius:999px;padding:.15rem .5rem;font-size:.85rem;margin:.1rem .25rem 0 0}
    .toast{position:fixed;top:12px;right:12px;z-index:9999;background:#0a84ff;color:#fff;padding:.55rem .7rem;border-radius:.6rem;display:none}
    .totals{display:flex;gap:.6rem;flex-wrap:wrap;align-items:center;padding:.5rem .6rem;border:1px solid #eee;border-radius:.6rem;background:#fbfbfb;margin:.5rem 0}
    .totals .badge{padding:.2rem .5rem;border:1px solid #e0e0e0;border-radius:999px}
    .drop{border:2px dashed #c9d1e6;border-radius:.6rem;padding:10px;background:#f8faff}
    .actions{display:flex;gap:.5rem;flex-wrap:wrap;margin:.6rem 0}
    footer{margin-top:2rem;padding:1rem 0;border-top:1px solid #ddd;display:flex;justify-content:space-between;align-items:center;font-size:.9rem;color:#666}
    a{color:#0a84ff;text-decoration:none}
    a:hover{text-decoration:underline}
    .alert{display:none;margin:.6rem 0;padding:.6rem .8rem;border:1px solid #ffd6d6;background:#fff2f2;color:#a40000;border-radius:.6rem}
    .alert b{color:#a40000}
    /* Modal-Hotfix */
    #adminModal{pointer-events:none}
    #adminModal[style*="display: flex"]{pointer-events:auto}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/idb-keyval@6/dist/idb-keyval-iife.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>window.pdfjsLib||=(window["pdfjs-dist/build/pdf"]);pdfjsLib.GlobalWorkerOptions.workerSrc="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";</script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js"></script>
  <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>
<body>
<div id="toast" class="toast"></div>
<header>
  <div>
    <h1>Presse Remi – Abgleich <span class="version">v27.2.8</span></h1>
    <div class="muted">Lokale Speicherung. Offline nutzbar.</div>
    <div class="banner">ℹ️ Rechnungen & Remissionen werden nur <u>3 Monate</u> intern gespeichert. Ältere Einträge werden automatisch gelöscht.</div>
    <div id="alertBox" class="alert"></div>
  </div>
  <div style="margin-left:auto;display:flex;gap:.5rem;align-items:center;">
    <button id="forceUpdate">Update erzwingen</button>
    <button id="repairDeep">Reparatur starten</button>
    <span class="pill">Vollversion</span>
  </div>
</header>

<div class="tabs">
  <div class="tab active" data-tab="main">Übersicht</div>
  <div class="tab" data-tab="settings">Einstellungen</div>
  <div class="tab" data-tab="stats">Statistik</div>
</div>

<section data-view="main">
  <h2>1) Daten eingeben</h2>
  <p class="muted">Option A: JSON einfügen • Option B: Datei importieren (PDF, EML, JSON) • Option C: per Gmail abrufen (nur Qtrado).</p>
  <textarea id="inputArea" placeholder='{"kundennummer":"","pakete":[],"rechnungen":{}}'></textarea>
  <div class="actions">
    <button id="saveBtn" class="primary">Speichern</button><button id="loadBtn">Laden</button><button id="clearBtn">Löschen</button>
    <button id="exportCsv">CSV</button><button id="exportPdf">PDF</button><button id="exportJson">JSON</button><button id="exportDiffCsv">Diff-CSV</button>
    <label><input id="importFile" type="file" accept=".json,.eml,application/pdf" style="display:none"><button id="importBtn">Import Datei</button></label>
    <span style="flex:1"></span><button id="gmailConnect">Gmail verbinden</button><button id="gmailFetch" disabled>E-Mails abrufen (Qtrado)</button>
  </div>
  <div class="drop" id="dropZone">Oder Datei per Drag&Drop hier ablegen</div>

  <h2>2) Filter</h2>
  <div class="actions">
    <select id="kdnrSelect"><option value="">Alle Kunden</option></select>
    <input id="searchInput" placeholder="Suchen… (Paket, Rechnung, Datum, Filiale)">
    <label>Von <input id="dateFrom" type="date"></label>
    <label>Bis <input id="dateTo" type="date"></label>
    <button id="toggleMissing">Nur abweichende anzeigen</button>
    <button id="clearSearch">Leeren</button>
  </div>

  <div id="totals" class="totals" hidden>
    <span class="badge" id="badgeCount">0 Pakete</span>
    <span class="badge" id="badgeMissing">0 abweichend</span>
    <span class="badge" id="badgeSum">Summe: –</span>
  </div>

  <h2>3) Übersicht</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:1rem;align-items:start">
    <div><h3>Pakete</h3><div id="overviewPackages" class="list"></div></div>
    <div><h3>Rechnungen</h3><div id="overviewInvoices" class="list"></div></div>
  </div>
</section>

<section data-view="settings" style="display:none;">
  <h2>Einstellungen</h2>
  <div style="display:grid;grid-template-columns:180px 1fr;gap:.5rem .75rem;max-width:720px;">
    <div>Erlaubter Absender 1</div><input id="allowed1" placeholder="z.B. remi@qtrado.de">
    <div>Erlaubter Absender 2</div><input id="allowed2" placeholder="optional">
    <div>Erlaubter Absender 3</div><input id="allowed3" placeholder="optional">
    <div>Suchwörter</div><input id="keywords" placeholder="z.B. Remission, Rechnung" value="Remission,Rechnung">
    <div></div><button id="settingsSave" class="primary">Speichern</button>
  </div>
  <p class="muted">Standard: es werden nur Absender mit „@qtrado.de“ verarbeitet.</p>
</section>

<section data-view="stats" style="display:none;">
  <h2>Statistik</h2>
  <div id="statsBox" class="card"></div>
</section>

<footer>
  <div>Made by Durdu 2025 – Version 27.2.8</div>
  <div><a href="#" id="adminLink">Admin Login</a></div>
</footer>

<!-- Admin Modal -->
<div id="adminModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.6);align-items:center;justify-content:center;z-index:9999">
  <div style="background:#fff;padding:1.2rem;border-radius:.6rem;max-width:320px;width:100%">
    <h3>Admin Login</h3>
    <label>Benutzername<br><input type="text" id="adminUser" style="width:100%;margin:.3rem 0"></label>
    <label>Passwort<br><input type="password" id="adminPass" style="width:100%;margin:.3rem 0"></label>
    <div style="margin-top:.6rem;display:flex;gap:.5rem;justify-content:flex-end"><button id="adminCancel">Abbrechen</button><button id="adminSubmit" class="primary">Login</button></div>
  </div>
</div>
<section id="adminDashboard" style="display:none;margin-top:2rem">
  <h2>Admin Dashboard</h2>
  <p class="muted">Hier kannst du später Nutzerrechte, Einstellungen und Auswertungen verwalten.</p>
  <div id="adminContent" class="card">✅ Erfolgreich eingeloggt als Admin.</div>
</section>

<script>
/* ====== Setup & Globals ====== */
const APP_VERSION = "27.2.8";
const GOOGLE_CLIENT_ID = "836994805779-78af1p2hpubkidbklko086s93j165lv5.apps.googleusercontent.com";
let gisClient = null, accessToken = null;

/* Fehler-Toast */
window.addEventListener("error",(e)=>{
  const el = document.getElementById("toast");
  el.textContent = "Fehler: " + (e?.message || e.toString());
  el.style.display = "block";
});

/* Modal darf Klicks nicht blocken, wenn versteckt */
document.addEventListener("DOMContentLoaded", ()=>{
  const modal = document.getElementById("adminModal");
  if (modal) { modal.style.display="none"; modal.style.pointerEvents="none"; }
});

/* Tabs */
const TABS=[...document.querySelectorAll(".tab")],VIEWS=[...document.querySelectorAll("section[data-view]")];
function setTab(n){ TABS.forEach(t=>t.classList.toggle("active",t.dataset.tab===n)); VIEWS.forEach(v=>v.style.display=v.dataset.view===n?"":"none"); }
TABS.forEach(t=>t.addEventListener("click",()=>setTab(t.dataset.tab)));

/* ServiceWorker & Cache bust */
(async()=>{
  try{
    if ("serviceWorker" in navigator){
      const regs = await navigator.serviceWorker.getRegistrations();
      for (const r of regs) await r.unregister();
    }
    if ("caches" in window){
      const keys = await caches.keys();
      await Promise.all(keys.map(k=>caches.delete(k)));
    }
  }catch(e){}
})();

/* ====== Storage ====== */
const __idb = window.idbKeyval || {
  get: async k => JSON.parse(localStorage.getItem(k)||"null"),
  set: async (k,v)=> localStorage.setItem(k, JSON.stringify(v)),
  del: async k => localStorage.removeItem(k)
};
const {get,set,del} = __idb;
const KEY="presse-remi-daten-v13";
const SETTINGS_KEY="presse-remi-settings-v10";

async function ensureShape(d){
  d = d || {kundennummer:"", pakete:[], rechnungen:{}};
  d.pakete ||= []; d.rechnungen ||= {};
  for (const p of d.pakete){ p.files ||= []; p.positionen ||= []; p.rechnungen ||= []; p.differenzen ||= []; }
  for (const k of Object.keys(d.rechnungen)){ d.rechnungen[k].files ||= []; d.rechnungen[k].items ||= []; }
  return d;
}
const readStore  = async()=> ensureShape(await get(KEY));
const writeStore = async(o)=> set(KEY, await ensureShape(o));
const readSettings = ()=> get(SETTINGS_KEY).then(x=>x||({allowed1:"",allowed2:"",allowed3:"",keywords:"Remission,Rechnung"}));

/* ====== Utils ====== */
const $ = s=>document.querySelector(s);
const toast = m => { const el=document.getElementById("toast"); el.textContent=m; el.style.display="block"; setTimeout(()=>el.style.display="none",2500); };
const norm = s => (s||"").toString().toLowerCase();
const parseDateAny = s => s && /^\d{4}-\d{2}-\d{2}$/.test(s) ? new Date(s+"T00:00:00") : null;
function threeMonthsAgo(){ const d=new Date; d.setMonth(d.getMonth()-3); d.setHours(0,0,0,0); return d; }
function pruneOld(d){ const c=threeMonthsAgo(); d.pakete = (d.pakete||[]).filter(p=>{ const dt=parseDateAny(p.datum); return dt && dt>=c; }); return d; }
const fmtEuro=n=> typeof n==="number" ? new Intl.NumberFormat("de-DE",{style:"currency",currency:"EUR"}).format(n) : "";
function colorFor(str){ str=String(str||""); let h=0; for(let i=0;i<str.length;i++) h = h*31 + str.charCodeAt(i) >>> 0; const hues=[0,210,40,280,160,330,20,200,90,260,120,300,30,180,240]; const hue=hues[h%hues.length]; return `hsl(${hue} 75% 45%)`; }
function chipStyleFor(str){ const c=colorFor(str); return `color:${c};border-color:${c};background:color-mix(in hsl, ${c} 12%, white);`; }
const decodeB64Url = s => { try{ return atob(String(s||"").replace(/-/g,"+").replace(/_/g,"/")); }catch{ return ""; } };
const blobToDataUrl = b => new Promise(res=>{const r=new FileReader; r.onload=()=>res(r.result); r.readAsDataURL(b);});

/* Rechnungsnummern normalisieren & finden */
function normalizeRg(raw){
  if(!raw) return "";
  let r = String(raw).replace(/\D+/g,"");
  r = r.replace(/^0+/,"");
  if (r.length>12 && /\d{11}$/.test(r)) r=r.slice(-11);
  return r;
}
function extractInvoiceNumbersFromText(txt){
  if(!txt) return [];
  const out=new Set();
  const labeled=[
    /rechnungs?(?:nr|nummer)?\s*[:\-]?\s*(\d{5,18})/ig,
    /\brg\s*[:\-]?\s*(\d{5,18})\b/ig,
    /rechnung\s*[:\-]?\s*(\d{5,18})\b/ig,
    /beleg(?:nr)?\s*[:\-]?\s*(\d{5,18})\b/ig,
    /R-?G[\s:_-]*?(\d{5,18})\b/ig
  ];
  for (const re of labeled){ for (const m of txt.matchAll(re)) out.add(m[1]); }
  for (const m of txt.matchAll(/\b(\d{9,18})\b/g)){
    const num=m[1]; if(/^20\d{6,}$/.test(num)) continue; out.add(num);
  }
  return Array.from(out).map(normalizeRg).filter(Boolean);
}
function extractInvoiceNumbersFromFileName(name){
  if(!name) return [];
  const base = name.replace(/\.[a-z0-9]+$/i,"");
  const out=new Set();
  const patterns=[/\b(?:rg|rechnung|rechn|beleg)[\s:_-]*?(\d{5,18})\b/ig, /\b(\d{9,18})\b/g];
  for (const re of patterns){ for (const m of base.matchAll(re)) out.add(m[1]); }
  const parts=base.split(/[_\- ]+/);
  for(let i=parts.length-1;i>=0;i--){ const s=parts[i]; if(/^\d{9,18}$/.test(s)){ out.add(s); break; } }
  return Array.from(out).map(normalizeRg).filter(Boolean);
}

/* PDF lesen */
async function pdfBlobToText(b){
  const arr=await b.arrayBuffer();
  const pdf=await pdfjsLib.getDocument({data:arr}).promise;
  let t="";
  for(let i=1;i<=pdf.numPages;i++){
    const p=await pdf.getPage(i), c=await p.getTextContent();
    t += c.items.map(it=>it.str).join(" ") + "\n";
  }
  return t;
}
async function extractRgFromPdfBlob(b){ try{ return extractInvoiceNumbersFromText(await pdfBlobToText(b))||[]; }catch{ return []; } }

/* Remi vs Rechnung – Differenzen */
function diffItems(remi,inv){
  const idx=arr=>{
    const map=new Map;
    for (const it of arr||[]){
      const key=(it.code||"").toLowerCase()+"|"+(it.title||"").toLowerCase();
      const cur=map.get(key)||{qty:0,unit:null,total:0};
      cur.qty += Number(it.qty||0);
      cur.unit = cur.unit ?? it.unit ?? null;
      cur.total = (cur.total||0) + (Number(it.total||0)||0);
      map.set(key,cur);
    }
    return map;
  };
  const R=idx(remi), I=idx(inv), missing=[], extra=[], mismatch=[];
  for (const [key,rVal] of R.entries()){
    if(!I.has(key)){ missing.push({key,expected:rVal}); continue; }
    const iVal=I.get(key);
    if(Number(rVal.qty||0) !== Number(iVal.qty||0))
      mismatch.push({key,remiQty:rVal.qty,invQty:iVal.qty});
  }
  for (const [key,iVal] of I.entries()) if(!R.has(key)) extra.push({key,found:iVal});
  return {missing,extra,mismatch};
}

/* File-Refs verknüpfen */
function addFileRefToPackage(data,pnr,f){
  let p=(data.pakete||[]).find(x=>x.nr===pnr);
  if(!p){
    p={nr:pnr||"unbekannt",datum:"",status:"offen",rechnungen:[],positionen:[],differenzen:[],files:[]};
    (data.pakete||=[]).push(p);
  }
  p.files ||= [];
  p.files.push(f);
}
function addFileRefToInvoice(data,rgNr,f){
  rgNr = normalizeRg(rgNr);
  const r = (data.rechnungen[rgNr] || {nr:rgNr,datum:"",items:[],files:[]});
  r.files ||= [];
  r.files.push(f);
  data.rechnungen[rgNr] = r;
}

/* Merge/Analyse */
async function mergeParsedIntoStore(parsed,fileRef){
  let data=await readStore(); data=await ensureShape(data);

  if (parsed.type==="invoice" && parsed.rechnungen?.length){
    for (const _rg of parsed.rechnungen){
      const rg=normalizeRg(_rg);
      const r=data.rechnungen[rg]||{nr:rg,datum:parsed.datum||"",items:[],files:[]};
      if (parsed.items?.length){
        const seen=new Set(r.items.map(x=>x.code+"|"+x.title));
        for (const it of parsed.items){
          const key=(it.code||"")+"|"+(it.title||"");
          if(!seen.has(key)){ r.items.push(it); seen.add(key); }
        }
      }
      if (parsed.datum && !r.datum) r.datum = parsed.datum;
      if (fileRef) addFileRefToInvoice(data,rg,fileRef);
      data.rechnungen[rg]=r;
    }
  }

  if (parsed.paket || parsed.kdnr || parsed.items?.length){
    let p = parsed.paket ? (data.pakete||[]).find(x=>x.nr===parsed.paket) : null;
    if(!p){
      p={nr:parsed.paket||"unbekannt",datum:parsed.datum||"",status:"offen",rechnungen:[],positionen:[],differenzen:[],files:[]};
      (data.pakete||[]).push(p);
    }
    if (parsed.kdnr) p.kundennummer=parsed.kdnr;
    if (parsed.datum && !p.datum) p.datum=parsed.datum;

    if (parsed.type!=="invoice" && parsed.items?.length){
      const seen=new Set(p.positionen.map(x=>x.code+"|"+x.title));
      for (const it of parsed.items){
        const key=(it.code||"")+"|"+(it.title||"");
        if(!seen.has(key)){ p.positionen.push(it); seen.add(key); }
      }
    }

    if (parsed.type==="invoice" && parsed.rechnungen?.length){
      for (const _rg of parsed.rechnungen){
        const rg=normalizeRg(_rg);
        if (!p.rechnungen.includes(rg)) p.rechnungen.push(rg);
      }
      if (p.files?.length){
        for (const _rg of parsed.rechnungen){
          const rg=normalizeRg(_rg);
          for (const f of p.files) addFileRefToInvoice(data,rg,f);
        }
      }
    }

    if (fileRef && parsed.paket){
      addFileRefToPackage(data,parsed.paket,fileRef);
      const pkgNow=(data.pakete||[]).find(x=>x.nr===parsed.paket);
      if (pkgNow?.rechnungen?.length){
        for (const _rg of pkgNow.rechnungen){
          const rg=normalizeRg(_rg);
          addFileRefToInvoice(data,rg,fileRef);
        }
      }
    }
  }

  /* Paket-Status + Differenzen */
  for (const p of data.pakete){
    p.differenzen=[];
    const linked=(p.rechnungen||[]).map(rg=>data.rechnungen[normalizeRg(rg)]).filter(Boolean);
    if (!linked.length){ p.status="offen"; continue; }
    let bad=false;
    for (const _rg of p.rechnungen||[]){
      const rg=normalizeRg(_rg), r=data.rechnungen[rg];
      if(!r) continue;
      const diffs=diffItems(p.positionen||[], r.items||[]);
      p.differenzen.push({rg, ...diffs});
      if (diffs.missing.length || diffs.extra.length || diffs.mismatch.length) bad=true;
    }
    p.status = bad ? "abweichung" : "ok";
  }

  data = pruneOld(data);
  await writeStore(data);
  if ($("#inputArea")) $("#inputArea").value = JSON.stringify(data,null,2);
  render(data);
  return true;
}

/* Migration: blob: -> data: */
async function migrateBlobUrlsToDataUrl(d){
  let changed=false;
  async function fix(list){
    for (const f of list||[]){
      if (!f) continue;
      if (!f.dataUrl && f.url && /^blob:/.test(f.url)){
        try{
          const res=await fetch(f.url), b=await res.blob(), r=new FileReader();
          f.dataUrl=await new Promise(ok=>{ r.onload=()=>ok(r.result); r.readAsDataURL(b); });
          changed=true;
        }catch{}
      }
    }
  }
  for (const p of d.pakete||[]) await fix(p.files);
  for (const r of Object.values(d.rechnungen||{})) await fix(r.files);
  if (changed) await writeStore(d);
  return changed;
}

/* Pakete mit RG aus PDF anreichern */
async function enrichPackagesWithRgFromFiles(d){
  let changed=false;
  for (const p of d.pakete||[]){
    const known=new Set(p.rechnungen||[]);
    for (const f of p.files||[]){
      if (f?.type!=="pdf") continue;
      const nameHits = extractInvoiceNumbersFromFileName(f.name||"")||[];
      let contentHits=[];
      if (nameHits.length===0){
        try{
          let b=null;
          if (f.dataUrl?.startsWith("data:application/pdf")){
            const bstr=atob(f.dataUrl.split(",")[1]||"");
            const arr=Uint8Array.from(bstr,c=>c.charCodeAt(0));
            b=new Blob([arr],{type:"application/pdf"});
          } else if (f.url){ const res=await fetch(f.url); b=await res.blob(); }
          if (b) contentHits = await extractRgFromPdfBlob(b);
        }catch{}
      }
      const hits=new Set([...(nameHits||[]), ...(contentHits||[])]);
      for (const rg of hits){
        const nrg=normalizeRg(rg);
        if (!known.has(nrg)){ p.rechnungen.push(nrg); known.add(nrg); changed=true; }
      }
    }
  }
  if (changed) await writeStore(d);
  return changed;
}

/* Rechnungen neu verlinken (aus allen PDFs) */
async function relinkInvoicesFromAllFiles(d){
  let changed=false;
  const all=[];
  for (const p of d.pakete||[]) for (const f of p.files||[]) if (f?.type==="pdf") all.push({scope:"paket",owner:p.nr,f});
  for (const r of Object.values(d.rechnungen||{})) for (const f of r.files||[]) if (f?.type==="pdf") all.push({scope:"rg",owner:r.nr,f});

  const idx=new Map();
  for (const x of all){
    const hits=new Set(extractInvoiceNumbersFromFileName(x.f.name||""));
    for (const rg of hits){
      const key=normalizeRg(rg), arr=idx.get(key)||[];
      arr.push(x.f); idx.set(key,arr);
    }
  }

  for (const [rgKey,rec] of Object.entries(d.rechnungen||{})){
    if (rec.files && rec.files.length) continue;
    const rg=normalizeRg(rgKey), byName=idx.get(rg)||[];
    if (byName.length){ rec.files=[...byName]; changed=true; continue; }

    for (const x of all){
      try{
        let b=null;
        if (x.f.dataUrl?.startsWith("data:application/pdf")){
          const bstr=atob(x.f.dataUrl.split(",")[1]||"");
          const arr=Uint8Array.from(bstr,c=>c.charCodeAt(0));
          b=new Blob([arr],{type:"application/pdf"});
        } else if (x.f.url){ const res=await fetch(x.f.url); b=await res.blob(); }
        if (!b) continue;
        const hits=await extractRgFromPdfBlob(b);
        if (hits.map(normalizeRg).includes(rg)){
          rec.files ||= [];
          if (!rec.files.some(ff=>ff.url===x.f.url && ff.name===x.f.name)){
            rec.files.push(x.f); changed=true;
          }
        }
      }catch{}
    }
  }
  if (changed) await writeStore(d);
  return changed;
}

/* ====== Rendering ====== */
const inputArea=$("#inputArea"), kdnrSelect=$("#kdnrSelect"), searchInput=$("#searchInput"),
      dateFrom=$("#dateFrom"), dateTo=$("#dateTo"), alertBox=$("#alertBox");
let onlyMissing=false;

function computeStats(d){
  const list=d.pakete||[];
  const abw=list.filter(p=>(p.differenzen||[]).some(d=>d.missing?.length||d.extra?.length||d.mismatch?.length)).length;
  const sum=list.reduce((a,p)=>a+(typeof p.summe==="number"?p.summe:0),0);
  return {pakete:list.length, abw, sum};
}
function filesHtml(files){
  files=files||[];
  if (!files.length) return '<span class="muted">keine PDF</span>';
  return files.map((f,i)=>{
    const has=!!f.dataUrl; const raw=has?f.dataUrl:(f.url||"");
    return `<a href="#" class="pdf-open" data-src="${raw}" data-hasdata="${has?"1":"0"}" data-file-idx="${i}">PDF ${i+1}</a>`;
  }).join(" • ");
}
function pkgRowHtml(p){
  const has=(p.differenzen||[]).some(x=>x.missing?.length||x.extra?.length||x.mismatch?.length);
  const re=(p.rechnungen||[]).map(r=>`<a href="#" data-open-rg="${normalizeRg(r)}" class="chip" style="${chipStyleFor(r)}" title="Rechnung öffnen">${normalizeRg(r)}</a>`).join("");
  const diffs=(p.differenzen||[]).map(d=>{
    const miss=(d.missing||[]).map(m=>{const[code,title]=String(m.key).split("|");return`<li>❌ fehlt: <b>${code||""}</b> – ${title||""} (Remi ${m.expected?.qty??"?"})</li>`}).join("");
    const extra=(d.extra||[]).map(e=>{const[code,title]=String(e.key).split("|");return`<li>➕ extra: <b>${code||""}</b> – ${title||""} (nur RG: ${e.found?.qty??"?"})</li>`}).join("");
    const mm=(d.mismatch||[]).map(x=>{const[code,title]=String(x.key).split("|");return`<li>⚖️ Menge abw.: <b>${code||""}</b> – ${title||""} (Remi ${x.remiQty??"?"}, RG ${x.invQty??"?"})</li>`}).join("");
    const ok=(!miss&&!extra&&!mm)?'<div class="muted">✓ Abgleich ok</div>':"";
    return `<div class="card" style="margin:.35rem 0;padding:.45rem .6rem;border-left:4px solid ${colorFor(d.rg)}">
      <div class="muted" style="margin-bottom:.2rem">Abgleich zu RG <b style="color:${colorFor(d.rg)}">${d.rg}</b></div>
      ${ok || `<ul style="margin:.2rem 0 .2rem 1rem">${miss}${extra}${mm}</ul>`}
    </div>`;
  }).join("") || '<div class="muted">Keine Abgleiche</div>';
  const statusLabel = p.status==="ok" ? "ok" : (p.status||"");
  return `<details class="card" ${has?"open":""}>
    <summary class="row">
      <div><a href="#" class="pkg-link" data-paket="${p.nr}"><b>Paket ${p.nr||""}</b></a></div>
      <div class="muted">${p.datum||""}</div>
      <div>${re || '<span class="muted">–</span>'}</div>
      <div class="muted" style="color:${p.status==="abweichung"?"#c00":"inherit"}">${statusLabel}</div>
    </summary>
    <div style="margin:.4rem 0 .2rem"><b>PDFs:</b> ${filesHtml(p.files)}</div>
    ${p.status==="offen" ? '<div class="muted" style="margin-top:.4rem">Noch keine Rechnung verknüpft – Abgleich nicht möglich.</div>' : diffs}
  </details>`;
}
function invRowHtml(r,data){
  const donor=[];
  for (const p of data.pakete||[]){
    if ((p.rechnungen||[]).includes(r.nr)){
      for (const f of p.files||[]){
        if (f?.type==="pdf" && !donor.some(x=>x.name===f.name && x.url===f.url)) donor.push(f);
      }
    }
  }
  const eff=[...(r.files||[]), ...donor];
  const items=(r.items||[]).slice(0,12).map(it=>`<li><b>${it.code||""}</b> – ${it.title||""} • Menge: ${it.qty??""}</li>`).join("");
  const noPdf = (!eff.length) ? '<div class="muted">Keine PDF verknüpft</div>' : "";
  return `<details class="card">
    <summary class="row">
      <div><a href="#" class="rg-link" data-rg="${r.nr}"><b>RG ${r.nr}</b></a></div>
      <div class="muted">${r.datum||""}</div>
      <div>${filesHtml(eff)}</div>
      <div class="muted">Positionen: ${(r.items||[]).length}</div>
    </summary>
    ${noPdf}
    <div style="margin:.4rem 0 .2rem">
      <button class="attachPdfBtn" data-rg="${r.nr}">PDF hinzufügen</button>
      <input type="file" accept="application/pdf" class="attachPdfInput" data-rg="${r.nr}" style="display:none">
    </div>
    ${items ? `<ul style="margin:.4rem 0 .2rem 1rem">${items}${(r.items||[]).length>12?'<li class="muted">…</li>':""}</ul>` : '<div class="muted">Keine Positionen erkannt</div>'}
  </details>`;
}

async function renderAlertBox(d){
  const pkgs=d.pakete||[], bad=pkgs.filter(p=>p.status==="abweichung");
  if (bad.length){
    alertBox.style.display="block";
    const max=6;
    const list=bad.slice(0,max).map(p=>`<li>Paket <b>${p.nr}</b> (${p.datum||"–"}) – Rechnungen: ${(p.rechnungen||[]).join(", ")||"–"}</li>`).join("");
    alertBox.innerHTML = `<b>⚠️ Abweichungen:</b> ${bad.length} Paket(e) betroffen.<ul style="margin:.4rem 0 .2rem 1rem">${list}${bad.length>max?'<li class="muted">…</li>':""}</ul>`;
  } else {
    alertBox.style.display="none";
    alertBox.innerHTML="";
  }
}

async function render(d){
  const fixed = await repairInvoiceFilesFromPackages(d);
  if (fixed) d=await readStore();

  const gk=d.kundennummer||"", q=norm($("#searchInput")?.value),
        ksel=$("#kdnrSelect")?.value, f=$("#dateFrom")?.value, t=$("#dateTo")?.value;

  const allPkgs=(d.pakete||[]).map(p=>({...p,_k:p.kundennummer||gk}));
  const pkgs=allPkgs.filter(p=>{
    const dt=parseDateAny(p.datum);
    const issues=(p.differenzen||[]).some(x=>x.missing?.length||x.extra?.length||x.mismatch?.length);
    return (!ksel||p._k===ksel)
      && (!q || [p.nr,p.datum,p.status,(p.rechnungen||[]).join(" "),p._k].some(x=>norm(x).includes(q)))
      && (!onlyMissing || issues)
      && (!f && !t ? true : (dt && (!f || dt>=new Date(f+"T00:00:00")) && (!t || dt<=new Date(t+"T23:59:59"))));
  });

  const invAll=Object.values(d.rechnungen||{});
  const invs=invAll.filter(r=>{
    const dt=parseDateAny(r.datum);
    return (!q || [r.nr,r.datum,(r.items||[]).map(x=>x.title).join(" ")].some(x=>norm(String(x)).includes(q)))
      && (!f && !t ? true : (dt && (!f || dt>=new Date(f+"T00:00:00")) && (!t || dt<=new Date(t+"T23:59:59"))));
  });

  $("#overviewPackages").innerHTML = pkgs.length ? pkgs.map(pkgRowHtml).join("") : '<div class="muted">Keine Pakete…</div>';
  $("#overviewInvoices").innerHTML = invs.length ? invs.map(r=>invRowHtml(r,d)).join("") : '<div class="muted">Keine Rechnungen…</div>';

  const s=computeStats({pakete:pkgs});
  if (pkgs.length){
    $("#totals").hidden=false;
    $("#badgeCount").textContent = `${s.pakete} Pakete`;
    $("#badgeMissing").textContent = `${s.abw} abweichend`;
    $("#badgeSum").textContent = `Summe: ${fmtEuro(s.sum)}`;
  } else {
    $("#totals").hidden=true;
  }

  renderAlertBox(d);

  /* KdNr Select auffüllen */
  const kset=new Set;
  if (d.kundennummer) kset.add(String(d.kundennummer));
  (d.pakete||[]).forEach(p=>{ if (p.kundennummer) kset.add(String(p.kundennummer)); });
  const cur=kdnrSelect.value;
  kdnrSelect.innerHTML = '<option value="">Alle Kunden</option>' + Array.from(kset).sort().map(k=>`<option>${k}</option>`).join("");
  if (cur && Array.from(kset).includes(cur)) kdnrSelect.value=cur;

  /* Klick auf RG-Chips => PDF öffnen (Fallback: Paket-PDF) */
  document.querySelectorAll("[data-open-rg]").forEach(a=>{
    a.addEventListener("click", async e=>{
      e.preventDefault();
      let d=await readStore();
      const rg=normalizeRg(a.getAttribute("data-open-rg")), r=(d.rechnungen||{})[rg];
      if (r?.files?.length){ await openPdfViewer(r.files[0]); return; }
      const donor=(d.pakete||[]).find(p=>(p.rechnungen||[]).map(normalizeRg).includes(rg) && p.files && p.files.length);
      if (donor){ await openPdfViewer(donor.files[0]); return; }
      toast("Zu dieser Rechnung ist keine PDF verknüpft.");
    });
  });
}

/* Rechnungs-PDFs aus Paket-PDFs übernehmen */
async function repairInvoiceFilesFromPackages(d){
  let changed=false;
  for (const [rgKey,r] of Object.entries(d.rechnungen||{})){
    if (r.files && r.files.length) continue;
    const rg=normalizeRg(rgKey);
    const donors=(d.pakete||[]).filter(p=>(p.rechnungen||[]).map(normalizeRg).includes(rg) && p.files && p.files.length);
    if (!donors.length) continue;
    r.files ||= [];
    for (const p of donors) for (const f of p.files){
      if (!r.files.some(x=>x.url===f.url && x.name===f.name)){ r.files.push(f); changed=true; }
    }
    d.rechnungen[rg]=r;
  }
  if (changed) await writeStore(d);
  return changed;
}

/* ====== Parser für EML/Text (einfach) ====== */
(function(g){
  if (typeof g.scanTextForFields==="function") return;
  function extractItemsFromText(txt){
    const items=[], lines=(txt||"").split(/\n+/);
    for (const line of lines){
      let m = line.match(/^\s*(\d+)\s*[x×]\s+(.+?)\s*(?:\b(Stk|Stück|Ex|Ex\.)\b.*)?$/i)
           || line.match(/^\s*(.+?)\s+(\d+)\s*(Stk|Stück|Ex|Ex\.)\b/i)
           || line.match(/^\s*(\d+)\s*(Stk|Stück|Ex|Ex\.)\s+(.+?)\s*$/i);
      if (m){
        if(/^\d+$/.test(m[1]) && m[2]) items.push({title:(m[2]||m[3]||"").trim(), qty:Number(m[1])});
        else if (m[1] && /^\d+$/.test(m[2])) items.push({title:m[1].trim(), qty:Number(m[2])});
      }
    }
    return items;
  }
  g.scanTextForFields = function(s){
    const txt=(s||"").replace(/\r/g," ");
    const out={type:"unknown", paket:"", kdnr:"", datum:"", rechnungen:[], items:[]};
    const mK=txt.match(/\b(?:kunden(?:nummer)?|kdnr)\s*[:\-]?\s*([0-9]{3,})/i); if(mK) out.kdnr=mK[1];
    const mP=txt.match(/\bpaket(?:nr|nummer)?\s*[:\-]?\s*([0-9]{3,})\b/i); if(mP) out.paket=mP[1];
    let mD=txt.match(/\b(20\d{2})[.\-](\d{2})[.\-](\d{2})\b/);
    if (mD) out.datum=`${mD[1]}-${mD[2]}-${mD[3]}`;
    else { mD=txt.match(/\b(\d{2})\.(\d{2})\.(20\d{2})\b/); if(mD) out.datum=`${mD[3]}-${mD[2]}-${mD[1]}`; }
    try{ out.rechnungen=(extractInvoiceNumbersFromText(txt)||[]).map(normalizeRg); }catch{ out.rechnungen=[]; }
    if (out.rechnungen.length) out.type="invoice";
    out.items = extractItemsFromText(txt);
    return out;
  }
})(window);

/* ====== Datei-Import (JSON/EML/PDF) ====== */
document.getElementById("importBtn").addEventListener("click",()=>document.getElementById("importFile").click());
document.getElementById("importFile").addEventListener("change", async e=>{
  for (const f of Array.from(e.target.files||[])) await handleFile(f);
  e.target.value="";
});

const dropZone=document.getElementById("dropZone");
["dragenter","dragover"].forEach(ev=>dropZone.addEventListener(ev, e=>{e.preventDefault();dropZone.style.background="#eef3ff"}));
["dragleave","drop"].forEach(ev=>dropZone.addEventListener(ev, e=>{e.preventDefault();dropZone.style.background="#f8faff"}));
dropZone.addEventListener("drop", async e=>{
  for (const f of Array.from(e.dataTransfer.files||[])) await handleFile(f);
});

async function handleFile(file){
  const name=(file.name||"").toLowerCase();

  if (name.endsWith(".json")){
    const obj=JSON.parse(await file.text());
    await writeStore(pruneOld(obj));
    inputArea.value = JSON.stringify(await readStore(), null, 2);
    toast("JSON importiert ✅");
    render(await readStore());
    return;
  }

  if (name.endsWith(".eml")){
    const raw = await file.text();
    const subj=(raw.match(/^Subject:\s*(.+)$/mi)||[])[1]||"";
    const body=raw.split(/\r?\n\r?\n/).slice(1).join("\n");
    const parsed=scanTextForFields(subj+"\n"+body);
    await mergeParsedIntoStore(parsed,null);
    toast("EML importiert ✅");
    return;
  }

  if (name.endsWith(".pdf")){
    const blob=file;
    const dataUrl=await blobToDataUrl(blob);
    const url=URL.createObjectURL(blob);
    const text=await pdfBlobToText(blob);

    let parsed=scanTextForFields(text);
    const rgFromName=extractInvoiceNumbersFromFileName(file.name);
    const allRg=new Set([...(parsed.rechnungen||[]), ...rgFromName]);

    if (allRg.size===0){
      for (const m of text.matchAll(/\b(\d{9,18})\b/g)){
        const num=normalizeRg(m[1]);
        if (num && !/^20\d{6,}$/.test(num)) allRg.add(num);
      }
    }
    if (allRg.size===0 && rgFromName.length){
      let d=await readStore(); d=await ensureShape(d);
      for (const c of rgFromName) if (d.rechnungen && d.rechnungen[normalizeRg(c)]) allRg.add(normalizeRg(c));
    }

    const fileRef={name:file.name, url, dataUrl, type:"pdf", source:"upload"};

    if (allRg.size>0){
      for (const rg of allRg){
        let d=await readStore(); d=await ensureShape(d);
        addFileRefToInvoice(d,rg,fileRef);
        await writeStore(d);
      }
      parsed.rechnungen = Array.from(allRg);
      parsed.type = "invoice";
    }

    if (parsed.paket){
      let d=await readStore(); d=await ensureShape(d);
      addFileRefToPackage(d,parsed.paket,fileRef);
      const pkg=(d.pakete||[]).find(p=>p.nr===parsed.paket);
      if (pkg?.rechnungen?.length) for (const _rg of pkg.rechnungen) addFileRefToInvoice(d,normalizeRg(_rg),fileRef);
      await writeStore(d);
    }

    await mergeParsedIntoStore(parsed,fileRef);
    toast("PDF importiert ✅");
    return;
  }

  toast("Dateityp nicht unterstützt");
}

/* ====== Exporte ====== */
function exportJSONdata(d){
  const blob=new Blob([JSON.stringify(d,null,2)],{type:"application/json"});
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="remi-export.json"; a.click();
}
function exportCSV(d){
  const rows=[["Kdnr","Paket","Datum","Status","Rechnungen","Summe"]];
  (d.pakete||[]).forEach(p=>rows.push([
    p.kundennummer||d.kundennummer||"", p.nr||"", p.datum||"", p.status||"", (p.rechnungen||[]).join(" "), typeof p.summe==="number"?p.summe:""
  ]));
  const csv=rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(";")).join("\n");
  const blob=new Blob([csv],{type:"text/csv;charset=utf-8"});
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="remi-export.csv"; a.click();
}
async function exportPDFdoc(d){
  const {jsPDF}=window.jspdf; const doc=new jsPDF;
  doc.text("Presse Remi – Export",14,14);
  const rows=(d.pakete||[]).map(p=>[
    p.kundennummer||d.kundennummer||"", p.nr||"", p.datum||"", p.status||"",
    (p.rechnungen||[]).join(" "), typeof p.summe==="number"?new Intl.NumberFormat("de-DE",{style:"currency",currency:"EUR"}).format(p.summe):""
  ]);
  doc.autoTable({head:[["Kdnr","Paket","Datum","Status","Rechnungen","Summe"]], body:rows, startY:18, styles:{fontSize:9}});
  doc.save("remi-export.pdf");
}
function exportDiffCSV(d){
  const rows=[["Kdnr","Paket","Rechnung","Typ","Code","Titel","Remi-Menge","Rechn.-Menge"]];
  const kdnr=d.kundennummer||"";
  for (const p of d.pakete||[]){
    const baseK=p.kundennummer||kdnr||"";
    for (const df of p.differenzen||[]){
      for (const m of df.missing||[]){ const [code,title]=String(m.key).split("|"); rows.push([baseK,p.nr||"",df.rg||"","fehlt",code||"",title||"",m.expected?.qty??"","0"]); }
      for (const e of df.extra||[]){ const [code,title]=String(e.key).split("|"); rows.push([baseK,p.nr||"",df.rg||"","extra",code||"",title||"","0",e.found?.qty??""]); }
      for (const mm of df.mismatch||[]){ const [code,title]=String(mm.key).split("|"); rows.push([baseK,p.nr||"",df.rg||"","menge",code||"",title||"",mm.remiQty??"",mm.invQty??""]); }
    }
  }
  const csv=rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(";")).join("\n");
  const blob=new Blob([csv],{type:"text/csv;charset=utf-8"});
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="remi-differenzen.csv"; a.click();
}

/* ====== Filter/Buttons ====== */
const rerenderOnChange=async()=>render(await readStore());
function normalizeDateRange(){ const f=dateFrom.value, t=dateTo.value; if (f && t && new Date(f)>new Date(t)){ dateFrom.value=t; dateTo.value=f; } }

document.getElementById("forceUpdate").addEventListener("click", async()=>{
  try{
    if ("serviceWorker" in navigator){ const r=await navigator.serviceWorker.getRegistrations(); for (const x of r) await x.unregister(); }
    if ("caches" in window){ const k=await caches.keys(); await Promise.all(k.map(c=>caches.delete(c))); }
  }catch(e){}
  toast("Update erzwungen – neu laden…");
  setTimeout(()=>location.reload(true),600);
});

document.getElementById("repairDeep").addEventListener("click", async()=>{
  let d=await readStore();
  const a=await enrichPackagesWithRgFromFiles(d);
  d=await readStore();
  const b=await relinkInvoicesFromAllFiles(d);
  toast(`Reparatur abgeschlossen ${a||b?"✅":"– keine Änderungen"}`);
  render(await readStore());
});

document.getElementById("toggleMissing").addEventListener("click", async()=>{
  window.onlyMissing = !window.onlyMissing;
  toast(window.onlyMissing ? "Nur abweichende…" : "Alle anzeigen");
  render(await readStore());
});
document.getElementById("clearSearch").addEventListener("click", async()=>{
  searchInput.value=""; dateFrom.value=""; dateTo.value="";
  toast("Filter zurückgesetzt"); render(await readStore());
});

document.getElementById("saveBtn").addEventListener("click", async()=>{
  try{
    let obj=JSON.parse(document.getElementById("inputArea").value||"{}");
    obj = pruneOld(await ensureShape(obj||{kundennummer:"",pakete:[],rechnungen:{}}));
    await writeStore(obj);
    toast("Gespeichert ✅");
    render(obj);
  }catch(e){ toast("JSON-Fehler: "+e.message); }
});
document.getElementById("loadBtn").addEventListener("click", async()=>{
  let d=await readStore(); d=pruneOld(d); await writeStore(d);
  document.getElementById("inputArea").value = JSON.stringify(d,null,2);
  toast("Geladen ✅"); render(d);
});
document.getElementById("clearBtn").addEventListener("click", async()=>{
  await del(KEY); document.getElementById("inputArea").value=""; toast("Gelöscht ✅");
  render({kundennummer:"",pakete:[],rechnungen:{}});
});

document.getElementById("exportJson").addEventListener("click", async()=>exportJSONdata(await readStore()));
document.getElementById("exportCsv").addEventListener("click", async()=>exportCSV(await readStore()));
document.getElementById("exportPdf").addEventListener("click", async()=>exportPDFdoc(await readStore()));
document.getElementById("exportDiffCsv").addEventListener("click", async()=>exportDiffCSV(await readStore()));

searchInput.addEventListener("input",rerenderOnChange);
kdnrSelect.addEventListener("change",rerenderOnChange);
dateFrom.addEventListener("change",()=>{normalizeDateRange();rerenderOnChange()});
dateTo.addEventListener("change",()=>{normalizeDateRange();rerenderOnChange()});

/* ====== Gmail ====== */
document.getElementById("gmailConnect").addEventListener("click", ()=>{
  if(!window.google?.accounts?.oauth2){ toast("Google API nicht geladen – neu laden"); return; }
  gisClient = google.accounts.oauth2.initTokenClient({
    client_id: GOOGLE_CLIENT_ID,
    scope: "https://www.googleapis.com/auth/gmail.readonly",
    prompt: "consent",
    include_granted_scopes: true,
    callback: (resp)=>{
      if (resp?.access_token){ accessToken=resp.access_token; document.getElementById("gmailFetch").disabled=false; toast("Gmail verbunden ✅"); }
      else toast("Login abgebrochen");
    }
  });
  gisClient.requestAccessToken();
});

document.getElementById("gmailFetch").addEventListener("click", async()=>{
  try{
    if(!accessToken){ toast("Bitte zuerst „Gmail verbinden“"); return; }
    const s=await readSettings();
    const sender=["from:qtrado","from:@qtrado.de",s.allowed1,s.allowed2,s.allowed3].filter(Boolean).join(" OR ");
    const words=(s.keywords||"Remission,Rechnung").split(",").map(w=>w.trim()).filter(Boolean).map(w=>`"${w}"`).join(" OR ");
    const baseQ=[`(${sender})`, words?`(${words})`:"", "newer_than:365d"].filter(Boolean).join(" ");

    toast("Suche: "+baseQ);

    let imported=0, nextPageToken=null, rounds=0;
    const flatten = p => (p||[]).flatMap(x=>x?.parts?flatten(x.parts):[x]);

    do{
      rounds++;
      const url=`https://gmail.googleapis.com/gmail/v1/users/me/messages?q=${encodeURIComponent(baseQ)}&maxResults=200${nextPageToken?`&pageToken=${nextPageToken}`:""}`;
      const listResp=await fetch(url,{headers:{Authorization:`Bearer ${accessToken}`}});
      const list=await listResp.json();
      nextPageToken=list.nextPageToken||null;
      if(!listResp.ok){ toast(`Gmail-Fehler: ${listResp.status}`); break; }
      if(!list.messages?.length) break;

      for (const m of list.messages){
        const msg=await fetch(`https://gmail.googleapis.com/gmail/v1/users/me/messages/${m.id}?format=full`,{headers:{Authorization:`Bearer ${accessToken}`}}).then(r=>r.json());
        const headers=msg.payload?.headers||[];
        const from=(headers.find(h=>h.name==="From")?.value||"").toLowerCase();
        if(!(from.includes("qtrado")||from.includes("@qtrado.de"))) continue;

        const subject=headers.find(h=>h.name==="Subject")?.value||"";
        let bodyText="";
        const parts=msg.payload?.parts||[];
        const plain = parts.find(p=>p.mimeType==="text/plain") || msg.payload;
        if (plain?.body?.data) bodyText = decodeB64Url(plain.body.data);

        const baseParsed=scanTextForFields(subject+"\n"+bodyText);
        await mergeParsedIntoStore(baseParsed,null);

        const pdfParts = flatten(parts).filter(p=>p?.mimeType==="application/pdf");
        for (const p of pdfParts){
          const attId = p.body?.attachmentId;
          if (!attId) continue;
          const att = await fetch(`https://gmail.googleapis.com/gmail/v1/users/me/messages/${m.id}/attachments/${attId}`,{headers:{Authorization:`Bearer ${accessToken}`}}).then(r=>r.json());
          if (!att.data) continue;

          const bin=Uint8Array.from(decodeB64Url(att.data), c=>c.charCodeAt(0));
          const blob=new Blob([bin],{type:"application/pdf"});
          const url=URL.createObjectURL(blob);
          const dataUrl=await blobToDataUrl(blob);
          const text=await pdfBlobToText(blob);
          const parsed=scanTextForFields(text);
          const fileRef={name:(p.filename||"Anhang.pdf"), url, dataUrl, type:"pdf", source:"gmail"};

          if (parsed.rechnungen?.length){
            for (const rg of parsed.rechnungen){
              let d=await readStore(); d=await ensureShape(d);
              addFileRefToInvoice(d,rg,fileRef); await writeStore(d);
            }
          }
          if (parsed.paket){
            let d=await readStore(); d=await ensureShape(d);
            addFileRefToPackage(d,parsed.paket,fileRef); await writeStore(d);
          }
          await mergeParsedIntoStore(parsed,fileRef);
          imported++;
        }
      }
      if (rounds>=6) nextPageToken=null; // Safety
    } while (nextPageToken);

    toast(`Qtrado-E-Mails verarbeitet: ${imported}`);
  }catch(e){ console.error(e); toast("Gmail-Fehler: "+(e.message||e)); }
});

/* ====== Manuell PDF an Rechnung hängen ====== */
document.addEventListener("click", async e=>{
  const btn=e.target.closest(".attachPdfBtn");
  if (!btn) return;
  const rg=btn.getAttribute("data-rg");
  const inp=document.querySelector(`.attachPdfInput[data-rg="${rg}"]`);
  if (inp) inp.click();
});
document.addEventListener("change", async e=>{
  const inp=e.target.closest(".attachPdfInput");
  if (!inp || !inp.files || !inp.files[0]) return;
  const rg=normalizeRg(inp.getAttribute("data-rg"));
  const file=inp.files[0];
  const dataUrl=await blobToDataUrl(file);
  const url=URL.createObjectURL(file);
  const text=await pdfBlobToText(file);
  const parsed=scanTextForFields(text);
  parsed.rechnungen = Array.from(new Set([...(parsed.rechnungen||[]), rg]));
  const fileRef={name:file.name,url,dataUrl,type:"pdf",source:"manual"};
  let d=await readStore(); d=await ensureShape(d);
  addFileRefToInvoice(d,rg,fileRef); await writeStore(d);
  await mergeParsedIntoStore(parsed,fileRef);
  toast(`PDF zu RG ${rg} verknüpft ✅`);
});

/* ====== PDF Viewer (about:blank + embed data: URL) ====== */
async function ensurePdfDataUrl(fileOrUrl){
  if (typeof fileOrUrl==="string"){
    if (fileOrUrl.startsWith("data:application/pdf")) return fileOrUrl;
    const res=await fetch(fileOrUrl), b=await res.blob();
    return await blobToDataUrl(b);
  }
  const f=fileOrUrl||{};
  if (f.dataUrl && f.dataUrl.startsWith("data:application/pdf")) return f.dataUrl;
  if (f.url){
    const res=await fetch(f.url), b=await res.blob(), durl=await blobToDataUrl(b);
    try{
      let d=await readStore(), mut=false;
      for (const p of d.pakete||[]){
        const i=(p.files||[]).indexOf(f); if (i>=0){ p.files[i].dataUrl=durl; mut=true; }
      }
      for (const r of Object.values(d.rechnungen||{})){
        const i=(r.files||[]).indexOf(f); if (i>=0){ r.files[i].dataUrl=durl; mut=true; }
      }
      if (mut) await writeStore(d);
    }catch{}
    return durl;
  }
  throw new Error("Keine Quelle für PDF gefunden");
}
async function openPdfViewer(fileOrUrl){
  try{
    const dataUrl=await ensurePdfDataUrl(fileOrUrl);
    const w=window.open("about:blank","_blank","noopener");
    if(!w){ alert("Popup blockiert – bitte Popups erlauben."); return; }
    const html='<!doctype html><html><head><meta charset="utf-8"><title>PDF</title><meta name="viewport" content="width=device-width, initial-scale=1"/><style>html,body{height:100%;margin:0}embed{width:100%;height:100%;border:0}</style></head><body><embed src="'+dataUrl+'" type="application/pdf"/></body></html>';
    w.document.open(); w.document.write(html); w.document.close();
  }catch(e){ console.error(e); toast("PDF konnte nicht geöffnet werden."); }
}

/* ====== Link-Handler: Pakete/Rechnungen/PDF ====== */
document.addEventListener("click", function(e){
  const a=e.target.closest("a.rg-link, a.pkg-link, a.pdf-open");
  if (!a) return;
  e.preventDefault(); e.stopPropagation();
  (async()=>{
    const d=await readStore();
    if (a.classList.contains("rg-link")){
      const rg=normalizeRg(a.getAttribute("data-rg"));
      const r=(d.rechnungen||{})[rg];
      if (r?.files?.length){ await openPdfViewer(r.files[0]); return; }
      const donor=(d.pakete||[]).find(p=>(p.rechnungen||[]).map(normalizeRg).includes(rg) && p.files && p.files.length);
      if (donor){ await openPdfViewer(donor.files[0]); return; }
      return toast("Zu dieser Rechnung ist keine PDF verknüpft.");
    }
    if (a.classList.contains("pkg-link")){
      const nr=a.getAttribute("data-paket");
      const p=(d.pakete||[]).find(x=>x.nr===nr);
      if (p?.files?.length){ await openPdfViewer(p.files[0]); return; }
      return toast("Zu diesem Paket ist keine PDF verknüpft.");
    }
    if (a.classList.contains("pdf-open")){
      const src=a.getAttribute("data-src")||"";
      if (!src){ toast("Kein PDF verknüpft."); return; }
      await openPdfViewer(src); return;
    }
  })();
}, true);

/* ====== Init ====== */
(async()=>{
  setTab("main");
  await set(SETTINGS_KEY, await readSettings());

  let d=await readStore();
  d = pruneOld(d || {kundennummer:"",pakete:[],rechnungen:{}});
  await writeStore(d);

  /* Rechnungs-Keys migrieren/vereinheitlichen */
  try{
    d=await readStore();
    if (d && d.rechnungen){
      let changed=false;
      const nm={};
      for (const [k,v] of Object.entries(d.rechnungen)){
        const nk=normalizeRg(k);
        if (!nk){ changed=true; continue; }
        if (!nm[nk]) nm[nk] = {...v, nr:nk};
        else {
          const dst=nm[nk];
          dst.items=[...(dst.items||[]), ...(v.items||[])];
          dst.files=[...(dst.files||[]), ...(v.files||[])];
          if (!dst.datum && v.datum) dst.datum=v.datum;
          changed=true;
        }
      }
      if (changed){ d.rechnungen=nm; await writeStore(d); }
    }
  }catch{}

  await migrateBlobUrlsToDataUrl(d);
  await enrichPackagesWithRgFromFiles(await readStore());
  await relinkInvoicesFromAllFiles(await readStore());

  if ($("#inputArea")) $("#inputArea").value = JSON.stringify(await readStore(), null, 2);
  render(await readStore());
  toast("App geladen ✅ v"+APP_VERSION);
})();

/* ====== Admin Login (Demo) ====== */
const ADMIN_USER="admin", ADMIN_PASS="remi2025";
document.getElementById("adminLink").addEventListener("click", e=>{
  e.preventDefault();
  const m=document.getElementById("adminModal");
  m.style.display="flex"; m.style.pointerEvents="auto";
});
document.getElementById("adminCancel").addEventListener("click", ()=>{
  const m=document.getElementById("adminModal");
  m.style.display="none"; m.style.pointerEvents="none";
});
document.getElementById("adminSubmit").addEventListener("click", ()=>{
  const u=document.getElementById("adminUser").value.trim();
  const p=document.getElementById("adminPass").value.trim();
  if (u===ADMIN_USER && p===ADMIN_PASS){
    const m=document.getElementById("adminModal");
    m.style.display="none"; m.style.pointerEvents="none";
    document.getElementById("adminDashboard").style.display="block";
    toast("Admin Login erfolgreich ✅");
  } else {
    alert("❌ Falsche Zugangsdaten!");
  }
});
</script>
  <script>
/* --- BUTTON/LINK HOTFIX v27.2.8a --- */
/* 1) Alle <button> explizit zu "type=button" machen (verhindert ungewolltes Submit/Reload) */
(function(){
  document.querySelectorAll('button').forEach(b=>{
    if(!b.getAttribute('type')) b.setAttribute('type','button');
  });
})();

/* 2) Alle <a href="#">-Klicks global neutralisieren (kein Hash-Jump, kein „Seite blinzelt“) */
document.addEventListener('click', function (e) {
  const a = e.target.closest('a[href="#"]');
  if (!a) return;
  e.preventDefault();
  e.stopPropagation();
}, true);

/* 3) Falls irgendein JS-Fehler früh abbricht, zeigen wir ihn sichtbar an */
window.addEventListener('error', (e)=>{
  try {
    const el = document.getElementById('toast') || (function(){
      const d=document.createElement('div'); d.id='toast';
      d.style.cssText='position:fixed;top:12px;right:12px;background:#c00;color:#fff;padding:.6rem .8rem;border-radius:.5rem;z-index:99999';
      document.body.appendChild(d); return d;
    })();
    el.textContent = 'Fehler: ' + (e?.message || e.toString());
    el.style.display = 'block';
  } catch(_) {}
});

/* 4) Sanity-Check: Markiere interaktive Elemente kurz, um sicherzugehen, dass Events hängen */
(function(){
  const ids = ['forceUpdate','repairDeep','saveBtn','loadBtn','clearBtn','gmailConnect','gmailFetch','exportCsv','exportPdf','exportJson','exportDiffCsv'];
  ids.forEach(id=>{
    const el = document.getElementById(id);
    if (el) { el.style.outline='1px dashed #0a84ff44'; el.style.outlineOffset='2px'; }
  });
})();
</script>
</body>
</html>

